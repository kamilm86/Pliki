Aby prognozować narastającą sprzedaż od początku miesiąca do końca miesiąca, możemy skorzystać z danych historycznych sprzedaży i modelować narastającą sumę sprzedaży. W poniższym przykładzie wykorzystamy dane od 1 marca 2023 roku. Skupimy się na wykorzystaniu regresji liniowej, chociaż można też zastosować inne modele.

1. Importowanie bibliotek
Najpierw zaimportujemy niezbędne biblioteki.

python
Skopiuj kod
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.preprocessing import StandardScaler
2. Wczytanie danych
Załadujemy dane do Pandas DataFrame. Zakładamy, że mamy dane w pliku CSV.

python
Skopiuj kod
# Wczytanie danych
df = pd.read_csv('cumulative_sales_data.csv')

# Wyświetlenie pierwszych kilku wierszy danych
print(df.head())
3. Eksploracja danych
Zbadamy dane, aby zrozumieć ich strukturę i odnaleźć potencjalne wzorce.

python
Skopiuj kod
# Podstawowe informacje o danych
print(df.info())

# Opis statystyczny danych
print(df.describe())

# Wizualizacja danych sprzedażowych w czasie
plt.figure(figsize=(10, 6))
sns.lineplot(x='Date', y='CumulativeSales', data=df)
plt.title('Cumulative Sales Over Time')
plt.xlabel('Date')
plt.ylabel('Cumulative Sales')
plt.show()
4. Przygotowanie danych
Przygotujemy dane do modelowania, tj. podzielimy je na cechy (features) i etykiety (labels), a następnie na zbiór treningowy i testowy.

python
Skopiuj kod
# Przekształcenie daty na format daty
df['Date'] = pd.to_datetime(df['Date'])

# Tworzenie nowych cech z daty
df['Year'] = df['Date'].dt.year
df['Month'] = df['Date'].dt.month
df['Day'] = df['Date'].dt.day
df['DayOfWeek'] = df['Date'].dt.dayofweek

# Wybór cech i etykiety
features = df[['Year', 'Month', 'Day', 'DayOfWeek']]
labels = df['CumulativeSales']

# Podział danych na zbiory treningowy i testowy
X_train, X_test, y_train, y_test = train_test_split(features, labels, test_size=0.2, random_state=42)
5. Skalowanie danych
Ponieważ cechy takie jak Day mogą mieć różne skale, dobrze jest je skalować.

python
Skopiuj kod
# Inicjalizacja skalera
scaler = StandardScaler()

# Skalowanie cech
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)
6. Trening modelu
Wytrenujemy model regresji liniowej na danych treningowych.

python
Skopiuj kod
# Inicjalizacja i trening modelu
model = LinearRegression()
model.fit(X_train_scaled, y_train)

# Prognozowanie na zbiorze testowym
y_pred = model.predict(X_test_scaled)
7. Ewaluacja modelu
Ocenimy wydajność modelu za pomocą różnych metryk.

python
Skopiuj kod
# Obliczanie metryk ewaluacyjnych
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f'Mean Squared Error: {mse}')
print(f'R^2 Score: {r2}')

# Wizualizacja wyników
plt.figure(figsize=(10, 6))
plt.scatter(y_test, y_pred)
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'k--', lw=2)
plt.title('Actual vs Predicted Cumulative Sales')
plt.xlabel('Actual Cumulative Sales')
plt.ylabel('Predicted Cumulative Sales')
plt.show()
8. Wizualizacja wyników
Dodatkowe wizualizacje pomogą lepiej zrozumieć model i jego błędy.

python
Skopiuj kod
# Wizualizacja rzeczywistych vs prognozowanych wyników
plt.figure(figsize=(10, 6))
plt.scatter(y_test, y_pred)
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'k--', lw=2)
plt.title('Actual vs Predicted Cumulative Sales')
plt.xlabel('Actual Cumulative Sales')
plt.ylabel('Predicted Cumulative Sales')
plt.show()

# Wizualizacja rozkładu błędów
plt.figure(figsize=(10, 6))
sns.histplot(y_test - y_pred, kde=True)
plt.title('Distribution of Prediction Errors')
plt.xlabel('Error')
plt.ylabel('Frequency')
plt.show()
Podsumowanie
Powyższy program jest kompletnym rozwiązaniem do prognozowania narastającej sprzedaży od początku miesiąca do końca miesiąca, wykorzystując regresję liniową w Pythonie. Można go łatwo rozszerzyć i poprawić, wykorzystując bardziej zaawansowane techniki i modele, takie jak np. Random Forest, Gradient Boosting czy modele szeregów czasowych (np. ARIMA, LSTM).
